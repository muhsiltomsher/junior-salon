import { m as monaco_editor_core_star, __tla as __tla_0 } from "./monaco-editor-M3RTrEyd.min.js";
import { __tla as __tla_1 } from "../assets/dashboard-B6ltDXPX.js";
import "./preload-helper-BazNuh42.min.js";
import "./index-BhcUEIkR.min.js";
import "./runtime-dom.esm-bundler-5tPCrDgD.min.js";
import "./runtime-core.esm-bundler-LUlud-H8.min.js";
import "./isObject-8EXUDN8T.min.js";
import { __tla as __tla_2 } from "../assets/worker-W3fg9dm2.js";
import { __tla as __tla_3 } from "../assets/cssesc-DgwoVnGT.js";
import "./index-Dfa4cJMK.min.js";
import "./index.browser-BBNxE1As.min.js";
import "./index-B5VrHBO0.min.js";
import { __tla as __tla_4 } from "./index-DLCNveCc.min.js";
import "../assets/build-BaSXQmfn.js";
import "./index-DmkUm1CH.min.js";
import { __tla as __tla_5 } from "./index-CiedHqv8.min.js";
import "../assets/pre-process-ChG-s8ET.js";
import "./index-B8YHA8Ix.min.js";
import "./index-CvyxREt8.min.js";
import { __tla as __tla_6 } from "../assets/build-C4S0myzs.js";
import "../assets/resolve-config-D3CNF9bs.js";
import "./index-CMNY8QH5.min.js";
import "./get-C5gQxxub.min.js";
import "./_toKey-C72hUfwS.min.js";
import "./floating-ui.core-XFSvPU2w.min.js";
import "../assets/virtualRef-DG1xZSxh.js";
import "./set-CQpYICWN.min.js";
import "./_initCloneObject-DnPaCxTN.min.js";
import "./fuse-Gm-adH5Q.min.js";
let conf, language;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_1;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_2;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_3;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_4;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_5;
    } catch {
    }
  })(),
  (() => {
    try {
      return __tla_6;
    } catch {
    }
  })()
]).then(async () => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget);
  var monaco_editor_core_exports = {};
  __reExport(monaco_editor_core_exports, monaco_editor_core_star);
  var conf$1 = {
    wordPattern: /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g,
    comments: {
      lineComment: "//",
      blockComment: [
        "/*",
        "*/"
      ]
    },
    brackets: [
      [
        "{",
        "}"
      ],
      [
        "[",
        "]"
      ],
      [
        "(",
        ")"
      ]
    ],
    onEnterRules: [
      {
        beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
        afterText: /^\s*\*\/$/,
        action: {
          indentAction: monaco_editor_core_exports.languages.IndentAction.IndentOutdent,
          appendText: " * "
        }
      },
      {
        beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
        action: {
          indentAction: monaco_editor_core_exports.languages.IndentAction.None,
          appendText: " * "
        }
      },
      {
        beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
        action: {
          indentAction: monaco_editor_core_exports.languages.IndentAction.None,
          appendText: "* "
        }
      },
      {
        beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
        action: {
          indentAction: monaco_editor_core_exports.languages.IndentAction.None,
          removeText: 1
        }
      }
    ],
    autoClosingPairs: [
      {
        open: "{",
        close: "}"
      },
      {
        open: "[",
        close: "]"
      },
      {
        open: "(",
        close: ")"
      },
      {
        open: '"',
        close: '"',
        notIn: [
          "string"
        ]
      },
      {
        open: "'",
        close: "'",
        notIn: [
          "string",
          "comment"
        ]
      },
      {
        open: "`",
        close: "`",
        notIn: [
          "string",
          "comment"
        ]
      },
      {
        open: "/**",
        close: " */",
        notIn: [
          "string"
        ]
      }
    ],
    folding: {
      markers: {
        start: new RegExp("^\\s*//\\s*#?region\\b"),
        end: new RegExp("^\\s*//\\s*#?endregion\\b")
      }
    }
  };
  var language$1 = {
    operators: [
      "<=",
      ">=",
      "==",
      "!=",
      "===",
      "!==",
      "=>",
      "+",
      "-",
      "**",
      "*",
      "/",
      "%",
      "++",
      "--",
      "<<",
      "</",
      ">>",
      ">>>",
      "&",
      "|",
      "^",
      "!",
      "~",
      "&&",
      "||",
      "??",
      "?",
      ":",
      "=",
      "+=",
      "-=",
      "*=",
      "**=",
      "/=",
      "%=",
      "<<=",
      ">>=",
      ">>>=",
      "&=",
      "|=",
      "^=",
      "@"
    ],
    symbols: /[=><!~?:&|+\-*\/\^%]+/,
    escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
    digits: /\d+(_+\d+)*/,
    octaldigits: /[0-7]+(_+[0-7]+)*/,
    binarydigits: /[0-1]+(_+[0-1]+)*/,
    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,
    regexpctl: /[(){}\[\]\$\^|\-*+?\.]/,
    regexpesc: /\\(?:[bBdDfnrstvwWn0\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})/,
    tokenizer: {
      root: [
        [
          /[{}]/,
          "delimiter.bracket"
        ],
        {
          include: "common"
        }
      ],
      common: [
        [
          /#?[a-z_$][\w$]*/,
          {
            cases: {
              "@keywords": "keyword",
              "@default": "identifier"
            }
          }
        ],
        [
          /[A-Z][\w\$]*/,
          "type.identifier"
        ],
        {
          include: "@whitespace"
        },
        [
          /\/(?=([^\\\/]|\\.)+\/([dgimsuy]*)(\s*)(\.|;|,|\)|\]|\}|$))/,
          {
            token: "regexp",
            bracket: "@open",
            next: "@regexp"
          }
        ],
        [
          /[()\[\]]/,
          "@brackets"
        ],
        [
          /[<>](?!@symbols)/,
          "@brackets"
        ],
        [
          /!(?=([^=]|$))/,
          "delimiter"
        ],
        [
          /@symbols/,
          {
            cases: {
              "@operators": "delimiter",
              "@default": ""
            }
          }
        ],
        [
          /(@digits)[eE]([\-+]?(@digits))?/,
          "number.float"
        ],
        [
          /(@digits)\.(@digits)([eE][\-+]?(@digits))?/,
          "number.float"
        ],
        [
          /0[xX](@hexdigits)n?/,
          "number.hex"
        ],
        [
          /0[oO]?(@octaldigits)n?/,
          "number.octal"
        ],
        [
          /0[bB](@binarydigits)n?/,
          "number.binary"
        ],
        [
          /(@digits)n?/,
          "number"
        ],
        [
          /[;,.]/,
          "delimiter"
        ],
        [
          /"([^"\\]|\\.)*$/,
          "string.invalid"
        ],
        [
          /'([^'\\]|\\.)*$/,
          "string.invalid"
        ],
        [
          /"/,
          "string",
          "@string_double"
        ],
        [
          /'/,
          "string",
          "@string_single"
        ],
        [
          /`/,
          "string",
          "@string_backtick"
        ]
      ],
      whitespace: [
        [
          /[ \t\r\n]+/,
          ""
        ],
        [
          /\/\*\*(?!\/)/,
          "comment.doc",
          "@jsdoc"
        ],
        [
          /\/\*/,
          "comment",
          "@comment"
        ],
        [
          /\/\/.*$/,
          "comment"
        ]
      ],
      comment: [
        [
          /[^\/*]+/,
          "comment"
        ],
        [
          /\*\//,
          "comment",
          "@pop"
        ],
        [
          /[\/*]/,
          "comment"
        ]
      ],
      jsdoc: [
        [
          /[^\/*]+/,
          "comment.doc"
        ],
        [
          /\*\//,
          "comment.doc",
          "@pop"
        ],
        [
          /[\/*]/,
          "comment.doc"
        ]
      ],
      regexp: [
        [
          /(\{)(\d+(?:,\d*)?)(\})/,
          [
            "regexp.escape.control",
            "regexp.escape.control",
            "regexp.escape.control"
          ]
        ],
        [
          /(\[)(\^?)(?=(?:[^\]\\\/]|\\.)+)/,
          [
            "regexp.escape.control",
            {
              token: "regexp.escape.control",
              next: "@regexrange"
            }
          ]
        ],
        [
          /(\()(\?:|\?=|\?!)/,
          [
            "regexp.escape.control",
            "regexp.escape.control"
          ]
        ],
        [
          /[()]/,
          "regexp.escape.control"
        ],
        [
          /@regexpctl/,
          "regexp.escape.control"
        ],
        [
          /[^\\\/]/,
          "regexp"
        ],
        [
          /@regexpesc/,
          "regexp.escape"
        ],
        [
          /\\\./,
          "regexp.invalid"
        ],
        [
          /(\/)([dgimsuy]*)/,
          [
            {
              token: "regexp",
              bracket: "@close",
              next: "@pop"
            },
            "keyword.other"
          ]
        ]
      ],
      regexrange: [
        [
          /-/,
          "regexp.escape.control"
        ],
        [
          /\^/,
          "regexp.invalid"
        ],
        [
          /@regexpesc/,
          "regexp.escape"
        ],
        [
          /[^\]]/,
          "regexp"
        ],
        [
          /\]/,
          {
            token: "regexp.escape.control",
            next: "@pop",
            bracket: "@close"
          }
        ]
      ],
      string_double: [
        [
          /[^\\"]+/,
          "string"
        ],
        [
          /@escapes/,
          "string.escape"
        ],
        [
          /\\./,
          "string.escape.invalid"
        ],
        [
          /"/,
          "string",
          "@pop"
        ]
      ],
      string_single: [
        [
          /[^\\']+/,
          "string"
        ],
        [
          /@escapes/,
          "string.escape"
        ],
        [
          /\\./,
          "string.escape.invalid"
        ],
        [
          /'/,
          "string",
          "@pop"
        ]
      ],
      string_backtick: [
        [
          /\$\{/,
          {
            token: "delimiter.bracket",
            next: "@bracketCounting"
          }
        ],
        [
          /[^\\`$]+/,
          "string"
        ],
        [
          /@escapes/,
          "string.escape"
        ],
        [
          /\\./,
          "string.escape.invalid"
        ],
        [
          /`/,
          "string",
          "@pop"
        ]
      ],
      bracketCounting: [
        [
          /\{/,
          "delimiter.bracket",
          "@bracketCounting"
        ],
        [
          /\}/,
          "delimiter.bracket",
          "@pop"
        ],
        {
          include: "common"
        }
      ]
    }
  };
  conf = conf$1;
  language = {
    defaultToken: "invalid",
    tokenPostfix: ".js",
    keywords: [
      "break",
      "case",
      "catch",
      "class",
      "continue",
      "const",
      "constructor",
      "debugger",
      "default",
      "delete",
      "do",
      "else",
      "export",
      "extends",
      "false",
      "finally",
      "for",
      "from",
      "function",
      "get",
      "if",
      "import",
      "in",
      "instanceof",
      "let",
      "new",
      "null",
      "return",
      "set",
      "static",
      "super",
      "switch",
      "symbol",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "undefined",
      "var",
      "void",
      "while",
      "with",
      "yield",
      "async",
      "await",
      "of"
    ],
    typeKeywords: [],
    operators: language$1.operators,
    symbols: language$1.symbols,
    escapes: language$1.escapes,
    digits: language$1.digits,
    octaldigits: language$1.octaldigits,
    binarydigits: language$1.binarydigits,
    hexdigits: language$1.hexdigits,
    regexpctl: language$1.regexpctl,
    regexpesc: language$1.regexpesc,
    tokenizer: language$1.tokenizer
  };
});
export {
  __tla,
  conf,
  language
};
