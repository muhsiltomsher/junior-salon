import { g as getDefaultExportFromCjs } from "../assets/cssesc-DgwoVnGT.js";
import { r as requireLib } from "./index-CvyxREt8.min.js";
function word(value) {
  return {
    kind: "word",
    value
  };
}
function fun(value, nodes) {
  return {
    kind: "function",
    value,
    nodes
  };
}
function separator(value) {
  return {
    kind: "separator",
    value
  };
}
function walk(ast, visit, parent = null) {
  for (let i = 0; i < ast.length; i++) {
    let node = ast[i];
    let replacedNode = false;
    let replacedNodeOffset = 0;
    let status = visit(node, {
      parent,
      replaceWith(newNode) {
        if (replacedNode) return;
        replacedNode = true;
        if (Array.isArray(newNode)) {
          if (newNode.length === 0) {
            ast.splice(i, 1);
            replacedNodeOffset = 0;
          } else if (newNode.length === 1) {
            ast[i] = newNode[0];
            replacedNodeOffset = 1;
          } else {
            ast.splice(i, 1, ...newNode);
            replacedNodeOffset = newNode.length;
          }
        } else {
          ast[i] = newNode;
        }
      }
    }) ?? 0;
    if (replacedNode) {
      if (status === 0) {
        i--;
      } else {
        i += replacedNodeOffset - 1;
      }
      continue;
    }
    if (status === 2) return 2;
    if (status === 1) continue;
    if (node.kind === "function") {
      if (walk(node.nodes, visit, node) === 2) {
        return 2;
      }
    }
  }
}
function toCss(ast) {
  let css = "";
  for (const node of ast) {
    switch (node.kind) {
      case "word":
      case "separator": {
        css += node.value;
        break;
      }
      case "function": {
        css += node.value + "(" + toCss(node.nodes) + ")";
      }
    }
  }
  return css;
}
const BACKSLASH$1 = 92;
const CLOSE_PAREN$1 = 41;
const COLON = 58;
const COMMA = 44;
const DOUBLE_QUOTE$1 = 34;
const EQUALS = 61;
const GREATER_THAN = 62;
const LESS_THAN = 60;
const NEWLINE = 10;
const OPEN_PAREN$1 = 40;
const SINGLE_QUOTE$1 = 39;
const SLASH = 47;
const SPACE = 32;
const TAB = 9;
function parse(input) {
  input = input.replaceAll("\r\n", "\n");
  let ast = [];
  let stack = [];
  let parent = null;
  let buffer = "";
  let peekChar;
  for (let i = 0; i < input.length; i++) {
    let currentChar = input.charCodeAt(i);
    switch (currentChar) {
      // Current character is a `\` therefore the next character is escaped,
      // consume it together with the next character and continue.
      case BACKSLASH$1: {
        buffer += input[i] + input[i + 1];
        i++;
        break;
      }
      // Space and commas are bundled into separators
      //
      // E.g.:
      //
      // ```css
      // foo(bar, baz)
      //        ^^
      // ```
      case COLON:
      case COMMA:
      case EQUALS:
      case GREATER_THAN:
      case LESS_THAN:
      case NEWLINE:
      case SLASH:
      case SPACE:
      case TAB: {
        if (buffer.length > 0) {
          let node2 = word(buffer);
          if (parent) {
            parent.nodes.push(node2);
          } else {
            ast.push(node2);
          }
          buffer = "";
        }
        let start = i;
        let end = i + 1;
        for (; end < input.length; end++) {
          peekChar = input.charCodeAt(end);
          if (peekChar !== COLON && peekChar !== COMMA && peekChar !== EQUALS && peekChar !== GREATER_THAN && peekChar !== LESS_THAN && peekChar !== NEWLINE && peekChar !== SLASH && peekChar !== SPACE && peekChar !== TAB) {
            break;
          }
        }
        i = end - 1;
        let node = separator(input.slice(start, end));
        if (parent) {
          parent.nodes.push(node);
        } else {
          ast.push(node);
        }
        break;
      }
      // Start of a string.
      case SINGLE_QUOTE$1:
      case DOUBLE_QUOTE$1: {
        let start = i;
        for (let j = i + 1; j < input.length; j++) {
          peekChar = input.charCodeAt(j);
          if (peekChar === BACKSLASH$1) {
            j += 1;
          } else if (peekChar === currentChar) {
            i = j;
            break;
          }
        }
        buffer += input.slice(start, i + 1);
        break;
      }
      // Start of a function call.
      //
      // E.g.:
      //
      // ```css
      // foo(bar, baz)
      //    ^
      // ```
      case OPEN_PAREN$1: {
        let node = fun(buffer, []);
        buffer = "";
        if (parent) {
          parent.nodes.push(node);
        } else {
          ast.push(node);
        }
        stack.push(node);
        parent = node;
        break;
      }
      // End of a function call.
      //
      // E.g.:
      //
      // ```css
      // foo(bar, baz)
      //             ^
      // ```
      case CLOSE_PAREN$1: {
        let tail = stack.pop();
        if (buffer.length > 0) {
          let node = word(buffer);
          tail.nodes.push(node);
          buffer = "";
        }
        if (stack.length > 0) {
          parent = stack[stack.length - 1];
        } else {
          parent = null;
        }
        break;
      }
      // Everything else will be collected in the buffer
      default: {
        buffer += String.fromCharCode(currentChar);
      }
    }
  }
  if (buffer.length > 0) {
    ast.push(word(buffer));
  }
  return ast;
}
const BACKSLASH = 92;
const OPEN_CURLY = 123;
const CLOSE_CURLY = 125;
const OPEN_PAREN = 40;
const CLOSE_PAREN = 41;
const OPEN_BRACKET = 91;
const CLOSE_BRACKET = 93;
const DOUBLE_QUOTE = 34;
const SINGLE_QUOTE = 39;
const closingBracketStack = new Uint8Array(256);
function segment(input, separator2) {
  let stackPos = 0;
  let parts = [];
  let lastPos = 0;
  let len = input.length;
  let separatorCode = separator2.charCodeAt(0);
  for (let idx = 0; idx < len; idx++) {
    let char = input.charCodeAt(idx);
    if (stackPos === 0 && char === separatorCode) {
      parts.push(input.slice(lastPos, idx));
      lastPos = idx + 1;
      continue;
    }
    switch (char) {
      case BACKSLASH:
        idx += 1;
        break;
      // Strings should be handled as-is until the end of the string. No need to
      // worry about balancing parens, brackets, or curlies inside a string.
      case SINGLE_QUOTE:
      case DOUBLE_QUOTE:
        while (++idx < len) {
          let nextChar = input.charCodeAt(idx);
          if (nextChar === BACKSLASH) {
            idx += 1;
            continue;
          }
          if (nextChar === char) {
            break;
          }
        }
        break;
      case OPEN_PAREN:
        closingBracketStack[stackPos] = CLOSE_PAREN;
        stackPos++;
        break;
      case OPEN_BRACKET:
        closingBracketStack[stackPos] = CLOSE_BRACKET;
        stackPos++;
        break;
      case OPEN_CURLY:
        closingBracketStack[stackPos] = CLOSE_CURLY;
        stackPos++;
        break;
      case CLOSE_BRACKET:
      case CLOSE_CURLY:
      case CLOSE_PAREN:
        if (stackPos > 0 && char === closingBracketStack[stackPos - 1]) {
          stackPos--;
        }
        break;
    }
  }
  parts.push(input.slice(lastPos));
  return parts;
}
function withAlpha(value, alpha2) {
  if (alpha2 === null) return value;
  let alphaAsNumber = Number(alpha2);
  if (!Number.isNaN(alphaAsNumber)) {
    alpha2 = `${alphaAsNumber * 100}%`;
  }
  return `color-mix(in oklab, ${value} ${alpha2}, transparent)`;
}
const CSS_FUNCTIONS = {
  "--alpha": alpha,
  "--spacing": spacing,
  "--theme": theme,
  theme: legacyTheme
};
function alpha(_designSystem, _source, value, ...rest) {
  let [color, alpha2] = segment(value, "/").map((v) => v.trim());
  if (!color || !alpha2) {
    throw new Error(
      `The --alpha(\u2026) function requires a color and an alpha value, e.g.: \`--alpha(${color || "var(--my-color)"} / ${alpha2 || "50%"})\``
    );
  }
  if (rest.length > 0) {
    throw new Error(
      `The --alpha(\u2026) function only accepts one argument, e.g.: \`--alpha(${color || "var(--my-color)"} / ${alpha2 || "50%"})\``
    );
  }
  return withAlpha(color, alpha2);
}
function spacing(designSystem, _source, value, ...rest) {
  if (!value) {
    throw new Error(`The --spacing(\u2026) function requires an argument, but received none.`);
  }
  if (rest.length > 0) {
    throw new Error(
      `The --spacing(\u2026) function only accepts a single argument, but received ${rest.length + 1}.`
    );
  }
  let multiplier = designSystem.theme.resolve(null, ["--spacing"]);
  if (!multiplier) {
    throw new Error(
      "The --spacing(\u2026) function requires that the `--spacing` theme variable exists, but it was not found."
    );
  }
  return `calc(${multiplier} * ${value})`;
}
function theme(designSystem, source, path, ...fallback) {
  if (!path.startsWith("--")) {
    throw new Error(`The --theme(\u2026) function can only be used with CSS variables from your theme.`);
  }
  let inline = false;
  if (path.endsWith(" inline")) {
    inline = true;
    path = path.slice(0, -7);
  }
  if (source.kind === "at-rule") {
    inline = true;
  }
  let resolvedValue = designSystem.resolveThemeValue(path, inline);
  if (!resolvedValue) {
    if (fallback.length > 0) return fallback.join(", ");
    throw new Error(
      `Could not resolve value for theme function: \`theme(${path})\`. Consider checking if the variable name is correct or provide a fallback value to silence this error.`
    );
  }
  if (fallback.length === 0) {
    return resolvedValue;
  }
  let joinedFallback = fallback.join(", ");
  if (joinedFallback === "initial") return resolvedValue;
  if (resolvedValue === "initial") return joinedFallback;
  if (resolvedValue.startsWith("var(") || resolvedValue.startsWith("theme(") || resolvedValue.startsWith("--theme(")) {
    let valueAst = parse(resolvedValue);
    injectFallbackForInitialFallback(valueAst, joinedFallback);
    return toCss(valueAst);
  }
  return resolvedValue;
}
function legacyTheme(designSystem, _source, path, ...fallback) {
  path = eventuallyUnquote(path);
  let resolvedValue = designSystem.resolveThemeValue(path);
  if (!resolvedValue && fallback.length > 0) {
    return fallback.join(", ");
  }
  if (!resolvedValue) {
    throw new Error(
      `Could not resolve value for theme function: \`theme(${path})\`. Consider checking if the path is correct or provide a fallback value to silence this error.`
    );
  }
  return resolvedValue;
}
new RegExp(
  Object.keys(CSS_FUNCTIONS).map((x) => `${x}\\(`).join("|")
);
function eventuallyUnquote(value) {
  if (value[0] !== "'" && value[0] !== '"') return value;
  let unquoted = "";
  let quoteChar = value[0];
  for (let i = 1; i < value.length - 1; i++) {
    let currentChar = value[i];
    let nextChar = value[i + 1];
    if (currentChar === "\\" && (nextChar === quoteChar || nextChar === "\\")) {
      unquoted += nextChar;
      i++;
    } else {
      unquoted += currentChar;
    }
  }
  return unquoted;
}
function injectFallbackForInitialFallback(ast, fallback) {
  walk(ast, (node) => {
    if (node.kind !== "function") return;
    if (node.value !== "var" && node.value !== "theme" && node.value !== "--theme") return;
    if (node.nodes.length === 1) {
      node.nodes.push({
        kind: "word",
        value: `, ${fallback}`
      });
    } else {
      let lastNode = node.nodes[node.nodes.length - 1];
      if (lastNode.kind === "word" && lastNode.value === "initial") {
        lastNode.value = fallback;
      }
    }
  });
}
var libExports = requireLib();
const parseValue = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
export {
  parseValue as p
};
