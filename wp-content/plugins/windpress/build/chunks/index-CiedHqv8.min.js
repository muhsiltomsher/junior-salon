var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { _ as __vitePreload } from "./preload-helper-BazNuh42.min.js";
let init, lightningcssWasmFile, transform;
let __tla = (async () => {
  lightningcssWasmFile = "" + new URL("../assets/lightningcss_node-M7Ldppq0.wasm", import.meta.url).href;
  const NAPI_OK = 0;
  const NAPI_INVALID_ARG = 1;
  const NAPI_STRING_EXPECTED = 3;
  const NAPI_NUMBER_EXPECTED = 6;
  const NAPI_BOOLEAN_EXPECTED = 7;
  const NAPI_GENERIC_FAILURE = 9;
  const NAPI_PENDING_EXCEPTION = 10;
  const NAPI_CANCELED = 11;
  const NAPI_HANDLE_SCOPE_MISMATCH = 13;
  const NAPI_BIGINT_EXPECTED = 17;
  const NAPI_NO_EXTERNAL_BUFFERS_ALLOWED = 22;
  const NAPI_WRITABLE = 1 << 0;
  const NAPI_ENUMERABLE = 1 << 1;
  const NAPI_CONFIGURABLE = 1 << 2;
  const NAPI_STATIC = 1 << 10;
  const typedArrays = [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    BigInt64Array,
    BigUint64Array
  ];
  const environments = [];
  class Environment {
    constructor(instance) {
      __publicField(this, "scopes", []);
      __publicField(this, "referenceId", 1);
      __publicField(this, "references", /* @__PURE__ */ new Map());
      __publicField(this, "deferred", [
        null
      ]);
      __publicField(this, "wrappedObjects", /* @__PURE__ */ new WeakMap());
      __publicField(this, "externalObjects", /* @__PURE__ */ new WeakMap());
      __publicField(this, "buffers", /* @__PURE__ */ new Map());
      __publicField(this, "instanceData", 0);
      __publicField(this, "pendingException", null);
      __publicField(this, "_u32", new Uint32Array());
      __publicField(this, "_i32", new Int32Array());
      __publicField(this, "_u16", new Uint16Array());
      __publicField(this, "_u64", new BigUint64Array());
      __publicField(this, "_i64", new BigInt64Array());
      __publicField(this, "_f64", new Float64Array());
      __publicField(this, "_buf", new Uint8Array());
      this.id = environments.length;
      environments.push(this);
      this.instance = instance;
      this.table = instance.exports.__indirect_function_table;
      this.exports = {};
      this.pushScope();
      let values = this.scopes[this.scopes.length - 1];
      let exports = values.length;
      values.push(this.exports);
      try {
        if (this.instance.exports.napi_register_module_v1) {
          this.instance.exports.napi_register_module_v1(this.id, exports);
        }
        if (this.instance.exports.napi_register_wasm_v1) {
          this.instance.exports.napi_register_wasm_v1(this.id, exports);
        }
      } finally {
        this.popScope();
        if (this.pendingException) {
          let e = this.pendingException;
          this.pendingException = null;
          throw e;
        }
      }
    }
    destroy() {
      environments[this.id] = void 0;
    }
    getString(ptr, len = strlen(this.memory, ptr)) {
      return decoder.decode(this.memory.subarray(ptr, Math.max(0, ptr + len)));
    }
    pushScope() {
      let id = this.scopes.length;
      this.scopes.push(id ? [
        ...this.scopes[id - 1]
      ] : [
        void 0,
        null,
        globalThis,
        true,
        false
      ]);
      return id;
    }
    popScope() {
      this.scopes.pop();
      for (let [buffer, slice] of this.buffers) {
        if (buffer.byteLength && slice.byteLength) {
          buffer.set(slice);
        }
      }
      this.buffers.clear();
    }
    get(idx) {
      return this.scopes[this.scopes.length - 1][idx];
    }
    set(idx, value) {
      this.scopes[this.scopes.length - 1][idx] = value;
    }
    pushValue(value, scope = this.scopes.length - 1) {
      let values = this.scopes[scope];
      let id = values.length;
      values.push(value);
      return id;
    }
    createValue(value, result, scope) {
      if (typeof value === "boolean") {
        this.setPointer(result, value ? 3 : 4);
        return NAPI_OK;
      } else if (typeof value === "undefined") {
        this.setPointer(result, 0);
        return NAPI_OK;
      } else if (value === null) {
        this.setPointer(result, 1);
        return NAPI_OK;
      } else if (value === globalThis) {
        this.setPointer(result, 2);
        return NAPI_OK;
      }
      let id = this.pushValue(value, scope);
      this.setPointer(result, id);
      return NAPI_OK;
    }
    setPointer(ptr, value) {
      this.u32[ptr >> 2] = value;
      return NAPI_OK;
    }
    get u32() {
      if (this._u32.byteLength === 0) {
        this._u32 = new Uint32Array(this.instance.exports.memory.buffer);
      }
      return this._u32;
    }
    get i32() {
      if (this._i32.byteLength === 0) {
        this._i32 = new Int32Array(this.instance.exports.memory.buffer);
      }
      return this._i32;
    }
    get u16() {
      if (this._u16.byteLength === 0) {
        this._u16 = new Uint16Array(this.instance.exports.memory.buffer);
      }
      return this._u16;
    }
    get u64() {
      if (this._u64.byteLength === 0) {
        this._u64 = new BigUint64Array(this.instance.exports.memory.buffer);
      }
      return this._u64;
    }
    get i64() {
      if (this._i64.byteLength === 0) {
        this._i64 = new BigInt64Array(this.instance.exports.memory.buffer);
      }
      return this._i64;
    }
    get f64() {
      if (this._f64.byteLength === 0) {
        this._f64 = new Float64Array(this.instance.exports.memory.buffer);
      }
      return this._f64;
    }
    get memory() {
      if (this._buf.byteLength === 0) {
        this._buf = new Uint8Array(this.instance.exports.memory.buffer);
      }
      return this._buf;
    }
    getBufferInfo(buf2, ptr) {
      if (this.buffers.has(buf2)) {
        let b2 = this.buffers.get(buf2);
        this.setPointer(ptr, b2.byteOffset);
        return b2.byteLength;
      }
      if (buf2 instanceof ArrayBuffer) {
        let b2 = this.copyBuffer(new Uint8Array(buf2));
        this.setPointer(ptr, b2.byteOffset);
        return b2.byteLength;
      }
      if (buf2.buffer === this.instance.exports.memory.buffer) {
        this.setPointer(ptr, buf2.byteOffset);
        return buf2.byteLength;
      }
      let b = this.copyBuffer(new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      this.setPointer(ptr, b.byteOffset);
      return b.byteLength;
    }
    copyBuffer(data) {
      let ptr = this.instance.exports.napi_wasm_malloc(data.byteLength);
      let mem = this.memory;
      mem.set(data, ptr);
      let buf2 = mem.subarray(ptr, ptr + data.byteLength);
      let finalize = (_env, data2) => {
        if (this.instance.exports.napi_wasm_free) {
          this.instance.exports.napi_wasm_free(data2);
        }
      };
      finalizationRegistry.register(buf2, new FinalizeRecord(this.id, finalize, 0, ptr));
      this.buffers.set(data, buf2);
      return buf2;
    }
    createFunction(cb, data) {
      let env2 = this;
      let fn = env2.table.get(cb);
      let func = function(...args) {
        let scope = env2.pushScope();
        try {
          let values = env2.scopes[scope];
          let info = values.length;
          values.push({
            thisArg: this,
            args,
            data,
            newTarget: new.target
          });
          let res = fn(env2.id, info);
          return env2.get(res);
        } finally {
          env2.popScope();
          if (env2.pendingException) {
            let e = env2.pendingException;
            env2.pendingException = null;
            throw e;
          }
        }
      };
      return func;
    }
    readPropertyDescriptor(ptr) {
      let buf2 = this.u32;
      let utf8name = buf2[ptr++];
      let nameValue = buf2[ptr++];
      let method = buf2[ptr++];
      let getter = buf2[ptr++];
      let setter = buf2[ptr++];
      let val = buf2[ptr++];
      let attrs = buf2[ptr++];
      let data = buf2[ptr++];
      let name = utf8name ? this.getString(utf8name) : this.get(nameValue);
      let writable = Boolean(attrs & NAPI_WRITABLE);
      let enumerable = Boolean(attrs & NAPI_ENUMERABLE);
      let configurable = Boolean(attrs & NAPI_CONFIGURABLE);
      let isStatic = Boolean(attrs & NAPI_STATIC);
      let get = getter ? this.createFunction(getter, data) : void 0;
      let set = setter ? this.createFunction(setter, data) : void 0;
      let value = method ? this.createFunction(method, data) : val ? this.get(val) : void 0;
      let descriptor = {
        name,
        static: isStatic,
        configurable,
        enumerable
      };
      if (get || set) {
        descriptor.get = get;
        descriptor.set = set;
      } else if (value) {
        descriptor.writable = writable;
        descriptor.value = value;
      }
      return descriptor;
    }
  }
  const decoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
  });
  const latin1Decoder = new TextDecoder("latin1");
  const utf16Decoder = new TextDecoder("utf-16");
  const encoder = new TextEncoder();
  class FinalizeRecord {
    constructor(env2, finalize, hint, data) {
      this.env = env2;
      this.finalize = finalize;
      this.hint = hint;
      this.data = data;
    }
  }
  const finalizationRegistry = new FinalizationRegistry((buffer) => {
    if (buffer.finalize) {
      buffer.finalize(buffer.env, buffer.data, buffer.hint);
    }
  });
  class ExternalValue {
  }
  const threadsafeFunctions = [];
  class ThreadSafeFunction {
    constructor(env2, fn, nativeFn, context) {
      this.env = env2;
      this.fn = fn;
      this.nativeFn = nativeFn;
      this.context = context;
      this.id = threadsafeFunctions.length;
      threadsafeFunctions.push(this);
    }
  }
  const asyncWork = [
    null
  ];
  class AsyncWork {
    constructor(env2, execute, complete, data) {
      this.env = env2;
      this.execute = execute;
      this.complete = complete;
      this.data = data;
      this.id = asyncWork.length;
      asyncWork.push(this);
    }
  }
  const napi = {
    napi_open_handle_scope(env_id, result) {
      let env2 = environments[env_id];
      let id = env2.pushScope();
      return env2.setPointer(result, id);
    },
    napi_close_handle_scope(env_id, scope) {
      let env2 = environments[env_id];
      if (scope !== env2.scopes.length - 1) {
        return NAPI_HANDLE_SCOPE_MISMATCH;
      }
      env2.popScope();
      return NAPI_OK;
    },
    napi_open_escapable_handle_scope(env_id, result) {
      let env2 = environments[env_id];
      let id = env2.pushScope();
      return env2.setPointer(result, id);
    },
    napi_close_escapable_handle_scope(env_id, scope) {
      let env2 = environments[env_id];
      if (scope !== env2.scopes.length - 1) {
        return NAPI_HANDLE_SCOPE_MISMATCH;
      }
      env2.popScope();
      return NAPI_OK;
    },
    napi_escape_handle(env_id, scope_id, escapee, result) {
      let env2 = environments[env_id];
      let value = env2.get(escapee);
      return env2.createValue(value, result, scope_id - 1);
    },
    napi_create_object(env_id, result) {
      let env2 = environments[env_id];
      return env2.createValue({}, result);
    },
    napi_set_property(env_id, object, key, value) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.get(key);
      let val = env2.get(value);
      obj[name] = val;
      return NAPI_OK;
    },
    napi_get_property(env_id, object, key, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.get(key);
      return env2.createValue(obj[name], result);
    },
    napi_delete_property(env_id, object, key, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.get(key);
      let res = false;
      try {
        res = delete obj[name];
      } catch (err) {
      }
      if (result) {
        env2.memory[result] = res ? 1 : 0;
      }
      return NAPI_OK;
    },
    napi_has_property(env_id, object, key, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.get(key);
      env2.memory[result] = name in obj ? 1 : 0;
      return NAPI_OK;
    },
    napi_has_own_property(env_id, object, key, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.get(key);
      env2.memory[result] = obj.hasOwnProperty(name) ? 1 : 0;
      return NAPI_OK;
    },
    napi_set_named_property(env_id, object, utf8Name, value) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let val = env2.get(value);
      let name = env2.getString(utf8Name);
      obj[name] = val;
      return NAPI_OK;
    },
    napi_get_named_property(env_id, object, utf8Name, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.getString(utf8Name);
      return env2.createValue(obj[name], result);
    },
    napi_has_named_property(env_id, object, utf8Name, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let name = env2.getString(utf8Name);
      env2.memory[result] = name in obj ? 1 : 0;
      return NAPI_OK;
    },
    napi_get_property_names(env_id, object, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let properties = Object.keys(obj);
      return env2.createValue(properties, result);
    },
    napi_get_all_property_names(env_id, object, key_mode, key_filter, key_conversion, result) {
      throw new Error("not implemented");
    },
    napi_define_properties(env_id, object, property_count, properties) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let ptr = properties >> 2;
      for (let i = 0; i < property_count; i++) {
        let descriptor = env2.readPropertyDescriptor(ptr);
        Object.defineProperty(obj, descriptor.name, descriptor);
        ptr += 8;
      }
      return NAPI_OK;
    },
    napi_object_freeze(env_id, object) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      Object.freeze(obj);
      return NAPI_OK;
    },
    napi_object_seal(env_id, object) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      Object.seal(obj);
      return NAPI_OK;
    },
    napi_get_prototype(env_id, object, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      return env2.createValue(Object.getPrototypeOf(obj), result);
    },
    napi_define_class(env_id, utf8name, length, constructor, data, property_count, properties, result) {
      let env2 = environments[env_id];
      let func = env2.createFunction(constructor, data);
      Object.defineProperty(func, "name", {
        value: env2.getString(utf8name, length),
        configurable: true
      });
      let ptr = properties >> 2;
      for (let i = 0; i < property_count; i++) {
        let descriptor = env2.readPropertyDescriptor(ptr);
        if (descriptor.static) {
          Object.defineProperty(func, descriptor.name, descriptor);
        } else {
          Object.defineProperty(func.prototype, descriptor.name, descriptor);
        }
        ptr += 8;
      }
      return env2.createValue(func, result);
    },
    napi_create_reference(env_id, value, refcount, result) {
      let env2 = environments[env_id];
      let id = env2.referenceId++;
      env2.references.set(id, {
        value: env2.get(value),
        refcount
      });
      return env2.setPointer(result, id);
    },
    napi_delete_reference(env_id, ref) {
      let env2 = environments[env_id];
      env2.references.delete(ref);
      return NAPI_OK;
    },
    napi_get_reference_value(env_id, ref, result) {
      let env2 = environments[env_id];
      let reference = env2.references.get(ref);
      return env2.createValue(reference.value, result);
    },
    napi_reference_ref(env_id, ref, result) {
      let env2 = environments[env_id];
      let reference = env2.references.get(ref);
      reference.refcount++;
      return env2.setPointer(result, reference.refcount);
    },
    napi_reference_unref(env_id, ref, result) {
      let env2 = environments[env_id];
      let reference = env2.references.get(ref);
      if (reference.refcount === 0) {
        return NAPI_GENERIC_FAILURE;
      }
      reference.refcount--;
      return env2.setPointer(result, reference.refcount);
    },
    napi_add_env_cleanup_hook() {
      return NAPI_OK;
    },
    napi_remove_env_cleanup_hook() {
      return NAPI_OK;
    },
    napi_add_async_cleanup_hook() {
      return NAPI_OK;
    },
    napi_remove_async_cleanup_hook() {
      return NAPI_OK;
    },
    napi_set_instance_data(env_id, data, finalize_cb, finalize_hint) {
      let env2 = environments[env_id];
      env2.instanceData = data;
      return NAPI_OK;
    },
    napi_get_instance_data(env_id, data) {
      let env2 = environments[env_id];
      return env2.setPointer(data, env2.instanceData);
    },
    napi_get_boolean(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.setPointer(result, value ? 3 : 4);
    },
    napi_get_value_bool(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "boolean") {
        return NAPI_BOOLEAN_EXPECTED;
      }
      env2.memory[result] = val ? 1 : 0;
      return NAPI_OK;
    },
    napi_create_int32(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(value, result);
    },
    napi_get_value_int32(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "number") {
        return NAPI_NUMBER_EXPECTED;
      }
      env2.i32[result >> 2] = val;
      return NAPI_OK;
    },
    napi_create_uint32(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(value, result);
    },
    napi_get_value_uint32(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "number") {
        return NAPI_NUMBER_EXPECTED;
      }
      return env2.setPointer(result, val);
    },
    napi_create_int64(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(Number(value), result);
    },
    napi_get_value_int64(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "number") {
        return NAPI_NUMBER_EXPECTED;
      }
      env2.i64[result >> 3] = val;
      return NAPI_OK;
    },
    napi_create_double(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(value, result);
    },
    napi_get_value_double(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "number") {
        return NAPI_NUMBER_EXPECTED;
      }
      env2.f64[result >> 3] = val;
      return NAPI_OK;
    },
    napi_create_bigint_int64(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(BigInt.asIntN(64, value), result);
    },
    napi_get_value_bigint_int64(env_id, value, result, lossless) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "bigint") {
        return NAPI_BIGINT_EXPECTED;
      }
      env2.i64[result >> 3] = val;
      if (lossless) {
        env2.memory[lossless] = BigInt.asIntN(64, val) === val ? 1 : 0;
      }
      return NAPI_OK;
    },
    napi_create_bigint_uint64(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(BigInt.asUintN(64, value), result);
    },
    napi_get_value_bigint_uint64(env_id, value, result, lossless) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "bigint") {
        return NAPI_BIGINT_EXPECTED;
      }
      env2.u64[result >> 3] = val;
      if (lossless) {
        env2.memory[lossless] = BigInt.asUintN(64, val) === val ? 1 : 0;
      }
      return NAPI_OK;
    },
    napi_create_bigint_words(env_id, sign_bit, word_count, words, result) {
      let env2 = environments[env_id];
      let buf2 = env2.u64;
      let ptr = words >> 3;
      let res = 0n;
      let shift = 0n;
      for (let i = 0; i < word_count; i++) {
        let word = buf2[ptr++];
        res += word << shift;
        shift += 64n;
      }
      res *= BigInt((-1) ** sign_bit);
      return env2.createValue(res, result);
    },
    napi_get_value_bigint_words(env_id, value, sign_bit, word_count, words) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "bigint") {
        return NAPI_BIGINT_EXPECTED;
      }
      let count = env2.u32[word_count >> 2];
      if (sign_bit) {
        env2.i32[sign_bit] = val < 0n ? 1 : 0;
      }
      let i = 0;
      if (words) {
        let mask = (1n << 64n) - 1n;
        let buf2 = env2.u64;
        let ptr = words >> 3;
        if (val < 0n) {
          val = -val;
        }
        for (; i < count && val !== 0n; i++) {
          buf2[ptr++] = val & mask;
          val >>= 64n;
        }
      }
      while (val > 0n) {
        i++;
        val >>= 64n;
      }
      return env2.setPointer(word_count, i);
    },
    napi_get_null(env_id, result) {
      let env2 = environments[env_id];
      return env2.setPointer(result, 1);
    },
    napi_create_array(env_id, result) {
      let env2 = environments[env_id];
      return env2.createValue([], result);
    },
    napi_create_array_with_length(env_id, length, result) {
      let env2 = environments[env_id];
      return env2.createValue(new Array(length), result);
    },
    napi_set_element(env_id, object, index, value) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let val = env2.get(value);
      obj[index] = val;
      return NAPI_OK;
    },
    napi_get_element(env_id, object, index, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let val = obj[index];
      return env2.createValue(val, result);
    },
    napi_has_element(env_id, object, index, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      env2.memory[result] = obj.hasOwnProperty(index) ? 1 : 0;
      return NAPI_OK;
    },
    napi_delete_element(env_id, object, index, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let res = false;
      try {
        res = delete obj[index];
      } catch (err) {
      }
      if (result) {
        env2.memory[result] = res ? 1 : 0;
      }
      return NAPI_OK;
    },
    napi_get_array_length(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      return env2.setPointer(result, val.length);
    },
    napi_get_undefined(env_id, result) {
      let env2 = environments[env_id];
      return env2.setPointer(result, 0);
    },
    napi_create_function(env_id, utf8name, length, cb, data, result) {
      let env2 = environments[env_id];
      let func = env2.createFunction(cb, data);
      Object.defineProperty(func, "name", {
        value: env2.getString(utf8name, length),
        configurable: true
      });
      return env2.createValue(func, result);
    },
    napi_call_function(env_id, recv, func, argc, argv, result) {
      let env2 = environments[env_id];
      let thisArg = env2.get(recv);
      let fn = env2.get(func);
      let args = new Array(argc);
      let mem = env2.u32;
      for (let i = 0; i < argc; i++) {
        args[i] = env2.get(mem[argv >> 2]);
        argv += 4;
      }
      try {
        let res = fn.apply(thisArg, args);
        return env2.createValue(res, result);
      } catch (err) {
        env2.pendingException = err;
        return NAPI_PENDING_EXCEPTION;
      }
    },
    napi_new_instance(env_id, cons, argc, argv, result) {
      let env2 = environments[env_id];
      let Class = env2.get(cons);
      let args = new Array(argc);
      let mem = env2.u32;
      for (let i = 0; i < argc; i++) {
        args[i] = env2.get(mem[argv >> 2]);
        argv += 4;
      }
      try {
        let value = new Class(...args);
        return env2.createValue(value, result);
      } catch (err) {
        env2.pendingException = err;
        return NAPI_PENDING_EXCEPTION;
      }
    },
    napi_get_cb_info(env_id, cbinfo, argc, argv, thisArg, data) {
      let env2 = environments[env_id];
      let info = env2.get(cbinfo);
      env2.setPointer(argc, info.args.length);
      for (let i = 0; i < info.args.length; i++) {
        env2.createValue(info.args[i], argv);
        argv += 4;
      }
      env2.createValue(info.thisArg, thisArg);
      env2.setPointer(data, info.data);
      return NAPI_OK;
    },
    napi_get_new_target(env_id, cbinfo, result) {
      let env2 = environments[env_id];
      let info = env2.get(cbinfo);
      return env2.createValue(info.newTarget, result);
    },
    napi_create_threadsafe_function(env_id, func, async_resource, async_resource_name, max_queue_size, initial_thread_count, thread_finalize_data, thread_finalize_cb, context, call_js_cb, result) {
      let env2 = environments[env_id];
      let fn = func ? env2.get(func) : void 0;
      let cb = call_js_cb ? env2.table.get(call_js_cb) : void 0;
      let f = new ThreadSafeFunction(env2, fn, cb, context);
      if (thread_finalize_cb) {
        let cb2 = env2.table.get(thread_finalize_cb);
        finalizationRegistry.register(f, new FinalizeRecord(env_id, cb2, 0, f.id));
      }
      env2.setPointer(result, f.id);
      return NAPI_OK;
    },
    napi_ref_threadsafe_function() {
      return NAPI_OK;
    },
    napi_unref_threadsafe_function() {
      return NAPI_OK;
    },
    napi_acquire_threadsafe_function() {
      return NAPI_OK;
    },
    napi_release_threadsafe_function(func, mode) {
      threadsafeFunctions[func] = void 0;
      return NAPI_OK;
    },
    napi_call_threadsafe_function(func, data, is_blocking) {
      let f = threadsafeFunctions[func];
      f.env.pushScope();
      try {
        if (f.nativeFn) {
          let id = f.fn ? f.env.pushValue(f.fn) : 0;
          f.nativeFn(f.env.id, id, f.context, data);
        } else if (f.fn) {
          f.fn();
        }
      } finally {
        f.env.popScope();
      }
    },
    napi_get_threadsafe_function_context(func, result) {
      let f = threadsafeFunctions[func];
      f.env.setPointer(result, f.context);
      return NAPI_OK;
    },
    napi_create_async_work(env_id, async_resource, async_resource_name, execute, complete, data, result) {
      let env2 = environments[env_id];
      let executeFn = execute ? env2.table.get(execute) : void 0;
      let completeFn = complete ? env2.table.get(complete) : void 0;
      let w = new AsyncWork(env2, executeFn, completeFn, data);
      env2.setPointer(result, w.id);
      return NAPI_OK;
    },
    napi_delete_async_work(env2, work2) {
      asyncWork[work2] = void 0;
      return NAPI_OK;
    },
    napi_queue_async_work(env2, work2) {
      queueMicrotask(() => {
        let w = asyncWork[work2];
        if (w) {
          w.execute(env2, w.data);
          w.complete(env2, NAPI_OK, w.data);
        }
      });
      return NAPI_OK;
    },
    napi_cancel_async_work() {
      let w = asyncWork[work];
      w.complete(env, NAPI_CANCELED, w.data);
      asyncWork[work] = void 0;
      return NAPI_OK;
    },
    napi_throw(env_id, error) {
      let env2 = environments[env_id];
      env2.pendingException = env2.get(error);
      return NAPI_OK;
    },
    napi_throw_error(env_id, code, msg) {
      let env2 = environments[env_id];
      let err = new Error(env2.getString(msg));
      err.code = code;
      env2.pendingException = err;
      return NAPI_OK;
    },
    napi_throw_type_error(env_id, code, msg) {
      let env2 = environments[env_id];
      let err = new TypeError(env2.getString(msg));
      err.code = code;
      env2.pendingException = err;
      return NAPI_OK;
    },
    napi_throw_range_error(env_id, code, msg) {
      let env2 = environments[env_id];
      let err = new RangeError(env2.getString(msg));
      err.code = code;
      env2.pendingException = err;
      return NAPI_OK;
    },
    napi_create_error(env_id, code, msg, result) {
      let env2 = environments[env_id];
      let err = new Error(env2.get(msg));
      err.code = env2.get(code);
      return env2.createValue(err, result);
    },
    napi_create_type_error(env_id, code, msg, result) {
      let env2 = environments[env_id];
      let err = new TypeError(env2.get(msg));
      err.code = env2.get(code);
      return env2.createValue(err, result);
    },
    napi_create_range_error(env_id, code, msg, result) {
      let env2 = environments[env_id];
      let err = new RangeError(env2.get(msg));
      err.code = env2.get(code);
      return env2.createValue(err, result);
    },
    napi_get_and_clear_last_exception(env_id, result) {
      let env2 = environments[env_id];
      let e = env2.pendingException;
      env2.pendingException = null;
      return env2.createValue(e, result);
    },
    napi_is_exception_pending(env_id, result) {
      let env2 = environments[env_id];
      env2.memory[result] = env2.pendingException ? 1 : 0;
      return NAPI_OK;
    },
    napi_fatal_exception(env_id, err) {
      throw new Error("not implemented");
    },
    napi_fatal_error(location, location_len, message, message_len) {
      throw new Error("not implemented");
    },
    napi_get_global(env_id, result) {
      let env2 = environments[env_id];
      return env2.setPointer(result, 2);
    },
    napi_create_buffer(env_id, length, data, result) {
      let env2 = environments[env_id];
      let ptr = env2.instance.exports.napi_wasm_malloc(length);
      if (data) {
        env2.setPointer(data, ptr);
      }
      let buf2 = typeof globalThis.Buffer !== "undefined" ? globalThis.Buffer.from(env2.memory.buffer, ptr, length) : env2.memory.subarray(ptr, ptr + length);
      let finalize = (_env, data2) => {
        if (env2.instance.exports.napi_wasm_free) {
          env2.instance.exports.napi_wasm_free(data2);
        }
      };
      finalizationRegistry.register(buf2, new FinalizeRecord(env_id, finalize, 0, ptr));
      return env2.createValue(buf2, result);
    },
    napi_create_buffer_copy(env_id, length, data, result_data, result) {
      let env2 = environments[env_id];
      let ptr = env2.instance.exports.napi_wasm_malloc(length);
      env2.memory.set(env2.memory.subarray(data, data + length), ptr);
      if (result_data) {
        env2.setPointer(result_data, ptr);
      }
      let res = typeof globalThis.Buffer !== "undefined" ? globalThis.Buffer.from(env2.memory.buffer, ptr, length) : env2.memory.subarray(ptr, ptr + length);
      let finalize = (_env, data2) => {
        if (env2.instance.exports.napi_wasm_free) {
          env2.instance.exports.napi_wasm_free(data2);
        }
      };
      finalizationRegistry.register(buf, new FinalizeRecord(env_id, finalize, 0, ptr));
      return env2.createValue(res, result);
    },
    napi_create_external_buffer(env_id, length, data, finalize_cb, finalize_hint, result) {
      let env2 = environments[env_id];
      let buf2 = typeof globalThis.Buffer !== "undefined" ? globalThis.Buffer.from(env2.memory.buffer, data, length) : env2.memory.subarray(data, data + length);
      if (finalize_cb) {
        let cb = env2.table.get(finalize_cb);
        finalizationRegistry.register(buf2, new FinalizeRecord(env_id, cb, finalize_hint, data));
      }
      return env2.createValue(buf2, result);
    },
    napi_get_buffer_info(env_id, value, data, length) {
      let env2 = environments[env_id];
      let buf2 = env2.get(value);
      let len = env2.getBufferInfo(buf2, data);
      return env2.setPointer(length, len);
    },
    napi_create_arraybuffer(env_id, length, data, result) {
      let env2 = environments[env_id];
      let buf2 = new ArrayBuffer(length);
      if (data) {
        env2.getBufferInfo(buf2, data);
      }
      return env2.createValue(buf2, result);
    },
    napi_create_external_arraybuffer(env_id, data, length, finalize_cb, finalize_hint, result) {
      return NAPI_NO_EXTERNAL_BUFFERS_ALLOWED;
    },
    napi_get_arraybuffer_info(env_id, value, data, length) {
      let env2 = environments[env_id];
      let len = env2.getBufferInfo(env2.get(value), data);
      return env2.setPointer(length, len);
    },
    napi_detach_arraybuffer(env_id, arraybuffer) {
      let env2 = environments[env_id];
      let buffer = env2.get(arraybuffer);
      if (typeof structuredClone === "function") {
        structuredClone(buffer, {
          transfer: [
            buffer
          ]
        });
      }
      return NAPI_OK;
    },
    napi_is_detached_arraybuffer(env_id, arraybuffer, result) {
      let env2 = environments[env_id];
      let buffer = env2.get(arraybuffer);
      env2.memory[result] = buffer.byteLength === 0 ? 1 : 0;
      return NAPI_OK;
    },
    napi_create_typedarray(env_id, type, length, arraybuffer, offset, result) {
      let env2 = environments[env_id];
      let Class = typedArrays[type];
      let buffer = env2.get(arraybuffer);
      let buf2 = new Class(buffer, offset, length);
      return env2.createValue(buf2, result);
    },
    napi_create_dataview(env_id, byte_length, arraybuffer, byte_offset, result) {
      let env2 = environments[env_id];
      let buffer = env2.get(arraybuffer);
      let view = new DataView(buffer, byte_offset, byte_length);
      return env2.createValue(view, result);
    },
    napi_get_typedarray_info(env_id, typedarray, type, length, data, arraybuffer, byte_offset) {
      let env2 = environments[env_id];
      let val = env2.get(typedarray);
      env2.setPointer(type, typedArrays.findIndex((constructor) => val instanceof constructor));
      env2.setPointer(length, val.length);
      env2.getBufferInfo(val, data);
      env2.createValue(val.buffer, arraybuffer);
      return env2.setPointer(byte_offset, val.byteOffset);
    },
    napi_get_dataview_info(env_id, dataview, byte_length, data, arraybuffer, byte_offset) {
      let env2 = environments[env_id];
      let val = env2.get(dataview);
      env2.setPointer(byte_length, val.byteLength);
      env2.getBufferInfo(val, data);
      env2.createValue(val.buffer, arraybuffer);
      return env2.setPointer(byte_offset, val.byteOffset);
    },
    napi_create_string_utf8(env_id, str, length, result) {
      let env2 = environments[env_id];
      let s = decoder.decode(env2.memory.subarray(str, str + length));
      return env2.createValue(s, result);
    },
    napi_get_value_string_utf8(env_id, value, buf2, bufsize, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "string") {
        return NAPI_STRING_EXPECTED;
      }
      if (buf2 == 0) {
        return env2.setPointer(result, utf8Length(val));
      }
      let res = encoder.encodeInto(val, env2.memory.subarray(buf2, buf2 + bufsize - 1));
      env2.memory[buf2 + res.written] = 0;
      return env2.setPointer(result, res.written);
    },
    napi_create_string_latin1(env_id, str, length, result) {
      let env2 = environments[env_id];
      let s = latin1Decoder.decode(env2.memory.subarray(str, str + length));
      return env2.createValue(s, result);
    },
    napi_get_value_string_latin1(env_id, value, buf2, bufsize, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "string") {
        return NAPI_STRING_EXPECTED;
      }
      if (buf2 == 0) {
        return env2.setPointer(result, val.length);
      }
      let mem = env2.memory;
      let len = Math.min(val.length, bufsize - 1);
      for (let i = 0; i < len; i++) {
        let code = val.charCodeAt(i);
        mem[buf2++] = code;
      }
      mem[buf2] = 0;
      return env2.setPointer(result, len);
    },
    napi_create_string_utf16(env_id, str, length, result) {
      let env2 = environments[env_id];
      let s = utf16Decoder.decode(env2.memory.subarray(str, str + length * 2));
      return env2.createValue(s, result);
    },
    napi_get_value_string_utf16(env_id, value, buf2, bufsize, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      if (typeof val !== "string") {
        return NAPI_STRING_EXPECTED;
      }
      if (buf2 == 0) {
        return env2.setPointer(result, val.length);
      }
      let mem = env2.u16;
      let ptr = buf2 >> 1;
      let len = Math.min(val.length, bufsize - 1);
      for (let i = 0; i < len; i++) {
        let code = val.charCodeAt(i);
        mem[ptr++] = code;
      }
      mem[ptr] = 0;
      return env2.setPointer(result, len);
    },
    napi_create_date(env_id, time, result) {
      let env2 = environments[env_id];
      return env2.createValue(new Date(time), result);
    },
    napi_get_date_value(env_id, value, result) {
      let env2 = environments[env_id];
      let date = env2.get(value);
      env2.f64[result >> 3] = date.valueOf();
    },
    napi_create_symbol(env_id, description, result) {
      let env2 = environments[env_id];
      let desc = env2.get(description);
      return env2.createValue(Symbol(desc), result);
    },
    napi_coerce_to_bool(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(Boolean(env2.get(value)), result);
    },
    napi_coerce_to_number(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(Number(env2.get(value)), result);
    },
    napi_coerce_to_object(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(Object(env2.get(value)), result);
    },
    napi_coerce_to_string(env_id, value, result) {
      let env2 = environments[env_id];
      return env2.createValue(String(env2.get(value)), result);
    },
    napi_typeof(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      return env2.setPointer(result, (() => {
        switch (typeof val) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "number":
            return 3;
          case "string":
            return 4;
          case "symbol":
            return 5;
          case "object":
            if (val === null) {
              return 1;
            } else if (val instanceof ExternalValue) {
              return 8;
            }
            return 6;
          case "function":
            return 7;
          case "bigint":
            return 9;
        }
      })());
    },
    napi_instanceof(env_id, object, constructor, result) {
      let env2 = environments[env_id];
      let obj = env2.get(object);
      let cons = env2.get(constructor);
      env2.memory[result] = obj instanceof cons ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_array(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      env2.memory[result] = Array.isArray(val) ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_buffer(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      env2.memory[result] = (typeof globalThis.Buffer !== "undefined" ? globalThis.Buffer.isBuffer(val) : val instanceof Uint8Array) ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_date(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      env2.memory[result] = val instanceof Date ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_error(env_id, value, result) {
      let env2 = environments[env_id];
      let err = env2.get(value);
      env2.memory[result] = err instanceof Error ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_typedarray(env_id, value, result) {
      let env2 = environments[env_id];
      let buf2 = env2.get(value);
      env2.memory[result] = ArrayBuffer.isView(buf2) && !(buf2 instanceof DataView) ? 1 : 0;
      return NAPI_OK;
    },
    napi_is_dataview(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      env2.memory[result] = val instanceof DataView ? 1 : 0;
      return NAPI_OK;
    },
    napi_strict_equals(env_id, lhs, rhs, result) {
      let env2 = environments[env_id];
      env2.memory[result] = env2.get(lhs) === env2.get(rhs) ? 1 : 0;
      return NAPI_OK;
    },
    napi_wrap(env_id, js_object, native_object, finalize_cb, finalize_hint, result) {
      let env2 = environments[env_id];
      let obj = env2.get(js_object);
      env2.wrappedObjects.set(obj, native_object);
      if (finalize_cb) {
        let cb = env2.table.get(finalize_cb);
        finalizationRegistry.register(obj, new FinalizeRecord(env_id, cb, finalize_hint, native_object));
      }
      if (result) {
        return napi.napi_create_reference(env_id, js_object, 1, result);
      }
      return NAPI_OK;
    },
    napi_unwrap(env_id, js_object, result) {
      let env2 = environments[env_id];
      let obj = env2.get(js_object);
      let native_object = env2.wrappedObjects.get(obj);
      env2.setPointer(result, native_object);
      return NAPI_OK;
    },
    napi_remove_wrap(env_id, js_object, result) {
      let env2 = environments[env_id];
      let obj = env2.get(js_object);
      let native_object = env2.wrappedObjects.get(obj);
      finalizationRegistry.unregister(obj);
      env2.wrappedObjects.delete(obj);
      return env2.setPointer(result, native_object);
    },
    napi_type_tag_object(env_id, js_object, type_tag) {
      throw new Error("not implemented");
    },
    napi_check_object_type_tag(env_id, js_object, type_tag) {
      throw new Error("not implemented");
    },
    napi_add_finalizer(env_id, js_object, native_object, finalize_cb, finalize_hint, result) {
      let env2 = environments[env_id];
      let obj = env2.get(js_object);
      let cb = env2.table.get(finalize_cb);
      finalizationRegistry.register(obj, new FinalizeRecord(env_id, cb, finalize_hint, native_object));
      if (result) {
        return napi.napi_create_reference(env_id, js_object, 1, result);
      }
      return NAPI_OK;
    },
    napi_create_promise(env_id, deferred, promise) {
      let env2 = environments[env_id];
      let p = new Promise((resolve, reject) => {
        let id = env2.deferred.length;
        env2.deferred.push({
          resolve,
          reject
        });
        env2.setPointer(deferred, id);
      });
      return env2.createValue(p, promise);
    },
    napi_resolve_deferred(env_id, deferred, resolution) {
      let env2 = environments[env_id];
      let { resolve } = env2.deferred[deferred];
      let value = env2.get(resolution);
      resolve(value);
      env2.deferred[deferred] = void 0;
      return NAPI_OK;
    },
    napi_reject_deferred(env_id, deferred, rejection) {
      let env2 = environments[env_id];
      let { reject } = env2.deferred[deferred];
      let value = env2.get(rejection);
      reject(value);
      env2.deferred[deferred] = void 0;
      return NAPI_OK;
    },
    napi_is_promise(env_id, value, result) {
      let env2 = environments[env_id];
      let val = env2.get(value);
      env2.memory[result] = val instanceof Promise ? 1 : 0;
      return NAPI_OK;
    },
    napi_run_script(env_id, script, result) {
      let env2 = environments[env_id];
      let source = env2.get(script);
      let res = (0, eval)(source);
      return env2.createValue(res, result);
    },
    napi_create_external(env_id, data, finalize_cb, finalize_hint, result) {
      let env2 = environments[env_id];
      let external = new ExternalValue();
      env2.externalObjects.set(external, data);
      if (finalize_cb) {
        let cb = env2.table.get(finalize_cb);
        finalizationRegistry.register(external, new FinalizeRecord(env_id, cb, finalize_hint, data));
      }
      return env2.createValue(external, result);
    },
    napi_get_value_external(env_id, value, result) {
      let env2 = environments[env_id];
      let external = env2.get(value);
      let val = env2.externalObjects.get(external);
      if (!val) {
        return NAPI_INVALID_ARG;
      }
      return env2.setPointer(result, val);
    },
    napi_adjust_external_memory() {
      return NAPI_OK;
    }
  };
  function strlen(buf2, ptr) {
    let len = 0;
    while (buf2[ptr] !== 0) {
      len++;
      ptr++;
    }
    return len;
  }
  function utf8Length(string) {
    let len = 0;
    for (let i = 0; i < string.length; i++) {
      let c = string.charCodeAt(i);
      if (c >= 55296 && c <= 56319 && i < string.length - 1) {
        let c2 = string.charCodeAt(++i);
        if ((c2 & 64512) === 56320) {
          c = ((c & 1023) << 10) + (c2 & 1023) + 65536;
        } else {
          i--;
        }
      }
      if ((c & 4294967168) === 0) {
        len++;
      } else if ((c & 4294965248) === 0) {
        len += 2;
      } else if ((c & 4294901760) === 0) {
        len += 3;
      } else if ((c & 4292870144) === 0) {
        len += 4;
      }
    }
    return len;
  }
  let cur_await_promise_sync;
  function await_promise_sync(promise_addr, result_addr, error_addr) {
    cur_await_promise_sync(promise_addr, result_addr, error_addr);
  }
  const State = {
    None: 0,
    Unwinding: 1,
    Rewinding: 2
  };
  function createBundleAsync(env2) {
    let { instance, exports } = env2;
    let { asyncify_get_state, asyncify_start_unwind, asyncify_stop_unwind, asyncify_start_rewind, asyncify_stop_rewind } = instance.exports;
    let DATA_ADDR = instance.exports.napi_wasm_malloc(8 + 4096);
    let DATA_START = DATA_ADDR + 8;
    let DATA_END = DATA_ADDR + 8 + 4096;
    new Int32Array(env2.memory.buffer, DATA_ADDR).set([
      DATA_START,
      DATA_END
    ]);
    function assertNoneState() {
      if (asyncify_get_state() !== State.None) {
        throw new Error(`Invalid async state ${asyncify_get_state()}, expected 0.`);
      }
    }
    let promise, result, error;
    cur_await_promise_sync = (promise_addr, result_addr, error_addr) => {
      let state = asyncify_get_state();
      if (state === State.Rewinding) {
        asyncify_stop_rewind();
        if (result != null) {
          env2.createValue(result, result_addr);
        }
        if (error != null) {
          env2.createValue(error, error_addr);
        }
        promise = result = error = null;
        return;
      }
      assertNoneState();
      promise = env2.get(promise_addr);
      asyncify_start_unwind(DATA_ADDR);
    };
    return async function bundleAsync(options) {
      assertNoneState();
      let res = exports.bundle(options);
      while (asyncify_get_state() === State.Unwinding) {
        asyncify_stop_unwind();
        try {
          result = await promise;
        } catch (err) {
          error = err;
        }
        assertNoneState();
        asyncify_start_rewind(DATA_ADDR);
        res = exports.bundle(options);
      }
      assertNoneState();
      return res;
    };
  }
  let wasm, initPromise;
  init = async function(input) {
    if (wasm) return;
    if (initPromise) {
      await initPromise;
      return;
    }
    input = input ?? new URL("" + new URL("../assets/lightningcss_node-M7Ldppq0.wasm", import.meta.url).href, import.meta.url);
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
      input = fetchOrReadFromFs(input);
    }
    let env2;
    initPromise = input.then((input2) => load(input2, {
      env: {
        ...napi,
        await_promise_sync,
        __getrandom_custom: (ptr, len) => {
          let buf2 = env2.memory.subarray(ptr, ptr + len);
          crypto.getRandomValues(buf2);
        }
      }
    })).then(({ instance }) => {
      instance.exports.register_module();
      env2 = new Environment(instance);
      createBundleAsync(env2);
      wasm = env2.exports;
    });
    await initPromise;
  };
  transform = function(options) {
    return wasm.transform(options);
  };
  async function load(module, imports) {
    if (typeof Response === "function" && module instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module, imports);
        } catch (e) {
          if (module.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = await module.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module, imports);
      if (instance instanceof WebAssembly.Instance) {
        return {
          instance,
          module
        };
      } else {
        return instance;
      }
    }
  }
  async function fetchOrReadFromFs(inputPath) {
    try {
      const fs = await __vitePreload(() => import("./index-CMNY8QH5.min.js").then((n) => n.i), true ? [] : void 0, import.meta.url);
      return fs.readFileSync(inputPath);
    } catch {
      return fetch(inputPath);
    }
  }
})();
export {
  __tla,
  init as i,
  lightningcssWasmFile as l,
  transform as t
};
