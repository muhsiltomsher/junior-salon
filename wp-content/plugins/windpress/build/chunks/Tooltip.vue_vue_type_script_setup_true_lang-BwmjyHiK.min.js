import { X as refAutoReset, j as createEventHook, Y as useForwardExpose, Z as injectTooltipProviderContext, h as useVModel, $ as useTimeoutFn, c as createContext, a0 as _sfc_main$8, u as useId, P as Primitive, a1 as _sfc_main$9, a2 as useEventListener, a3 as _sfc_main$a, a4 as _sfc_main$b, a5 as _sfc_main$c, O as useForwardProps, s as useForwardPropsEmits, a6 as Presence, a7 as _sfc_main$d, a8 as _sfc_main$e, a9 as defu, t as tv, aa as _sfc_main$f, r as _appConfig, __tla as __tla_0 } from "../assets/dashboard-B6ltDXPX.js";
import { r as ref, w as watchEffect, d as defineComponent, f as computed, j as watch, D as createBlock, E as openBlock, G as withCtx, H as renderSlot, u as unref, x as onMounted, N as createVNode, A as mergeProps, a6 as toHandlers, a4 as useSlots, C as Comment, a0 as createTextVNode, a1 as toDisplayString, a3 as resolveDynamicComponent, _ as normalizeProps, $ as guardReactiveProps, m as toRef, O as createCommentVNode, U as createElementBlock, a2 as normalizeClass, F as Fragment, V as renderList } from "./runtime-core.esm-bundler-LUlud-H8.min.js";
import { a as withModifiers } from "./runtime-dom.esm-bundler-5tPCrDgD.min.js";
import { r as reactivePick } from "./index-B5VrHBO0.min.js";
let _sfc_main;
let __tla = Promise.all([
  (() => {
    try {
      return __tla_0;
    } catch {
    }
  })()
]).then(async () => {
  var _a;
  function useGraceArea(triggerElement, containerElement) {
    const isPointerInTransit = refAutoReset(false, 300);
    const pointerGraceArea = ref(null);
    const pointerExit = createEventHook();
    function handleRemoveGraceArea() {
      pointerGraceArea.value = null;
      isPointerInTransit.value = false;
    }
    function handleCreateGraceArea(event, hoverTarget) {
      const currentTarget = event.currentTarget;
      const exitPoint = {
        x: event.clientX,
        y: event.clientY
      };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([
        ...paddedExitPoints,
        ...hoverTargetPoints
      ]);
      pointerGraceArea.value = graceArea;
      isPointerInTransit.value = true;
    }
    watchEffect((cleanupFn) => {
      if (triggerElement.value && containerElement.value) {
        const handleTriggerLeave = (event) => handleCreateGraceArea(event, containerElement.value);
        const handleContentLeave = (event) => handleCreateGraceArea(event, triggerElement.value);
        triggerElement.value.addEventListener("pointerleave", handleTriggerLeave);
        containerElement.value.addEventListener("pointerleave", handleContentLeave);
        cleanupFn(() => {
          var _a2, _b;
          (_a2 = triggerElement.value) == null ? void 0 : _a2.removeEventListener("pointerleave", handleTriggerLeave);
          (_b = containerElement.value) == null ? void 0 : _b.removeEventListener("pointerleave", handleContentLeave);
        });
      }
    });
    watchEffect((cleanupFn) => {
      var _a2;
      if (pointerGraceArea.value) {
        const handleTrackPointerGrace = (event) => {
          var _a3, _b;
          if (!pointerGraceArea.value || !(event.target instanceof HTMLElement)) return;
          const target = event.target;
          const pointerPosition = {
            x: event.clientX,
            y: event.clientY
          };
          const hasEnteredTarget = ((_a3 = triggerElement.value) == null ? void 0 : _a3.contains(target)) || ((_b = containerElement.value) == null ? void 0 : _b.contains(target));
          const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value);
          const isAnotherGraceAreaTrigger = !!target.closest("[data-grace-area-trigger]");
          if (hasEnteredTarget) {
            handleRemoveGraceArea();
          } else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {
            handleRemoveGraceArea();
            pointerExit.trigger();
          }
        };
        (_a2 = triggerElement.value) == null ? void 0 : _a2.ownerDocument.addEventListener("pointermove", handleTrackPointerGrace);
        cleanupFn(() => {
          var _a3;
          return (_a3 = triggerElement.value) == null ? void 0 : _a3.ownerDocument.removeEventListener("pointermove", handleTrackPointerGrace);
        });
      }
    });
    return {
      isPointerInTransit,
      onPointerExit: pointerExit.on
    };
  }
  function getExitSideFromRect(point, rect) {
    const top = Math.abs(rect.top - point.y);
    const bottom = Math.abs(rect.bottom - point.y);
    const right = Math.abs(rect.right - point.x);
    const left = Math.abs(rect.left - point.x);
    switch (Math.min(top, bottom, right, left)) {
      case left:
        return "left";
      case right:
        return "right";
      case top:
        return "top";
      case bottom:
        return "bottom";
      default:
        throw new Error("unreachable");
    }
  }
  function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
    const paddedExitPoints = [];
    switch (exitSide) {
      case "top":
        paddedExitPoints.push({
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        }, {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        });
        break;
      case "bottom":
        paddedExitPoints.push({
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        }, {
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        });
        break;
      case "left":
        paddedExitPoints.push({
          x: exitPoint.x + padding,
          y: exitPoint.y - padding
        }, {
          x: exitPoint.x + padding,
          y: exitPoint.y + padding
        });
        break;
      case "right":
        paddedExitPoints.push({
          x: exitPoint.x - padding,
          y: exitPoint.y - padding
        }, {
          x: exitPoint.x - padding,
          y: exitPoint.y + padding
        });
        break;
    }
    return paddedExitPoints;
  }
  function getPointsFromRect(rect) {
    const { top, right, bottom, left } = rect;
    return [
      {
        x: left,
        y: top
      },
      {
        x: right,
        y: top
      },
      {
        x: right,
        y: bottom
      },
      {
        x: left,
        y: bottom
      }
    ];
  }
  function isPointInPolygon(point, polygon) {
    const { x, y } = point;
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x;
      const yi = polygon[i].y;
      const xj = polygon[j].x;
      const yj = polygon[j].y;
      const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function getHull(points) {
    const newPoints = points.slice();
    newPoints.sort((a, b) => {
      if (a.x < b.x) return -1;
      else if (a.x > b.x) return 1;
      else if (a.y < b.y) return -1;
      else if (a.y > b.y) return 1;
      else return 0;
    });
    return getHullPresorted(newPoints);
  }
  function getHullPresorted(points) {
    if (points.length <= 1) return points.slice();
    const upperHull = [];
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      while (upperHull.length >= 2) {
        const q = upperHull[upperHull.length - 1];
        const r = upperHull[upperHull.length - 2];
        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();
        else break;
      }
      upperHull.push(p);
    }
    upperHull.pop();
    const lowerHull = [];
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      while (lowerHull.length >= 2) {
        const q = lowerHull[lowerHull.length - 1];
        const r = lowerHull[lowerHull.length - 2];
        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();
        else break;
      }
      lowerHull.push(p);
    }
    lowerHull.pop();
    if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
      return upperHull;
    } else {
      return upperHull.concat(lowerHull);
    }
  }
  const TOOLTIP_OPEN = "tooltip.open";
  const [injectTooltipRootContext, provideTooltipRootContext] = createContext("TooltipRoot");
  const _sfc_main$7 = defineComponent({
    __name: "TooltipRoot",
    props: {
      defaultOpen: {
        type: Boolean,
        default: false
      },
      open: {
        type: Boolean,
        default: void 0
      },
      delayDuration: {
        default: void 0
      },
      disableHoverableContent: {
        type: Boolean,
        default: void 0
      },
      disableClosingTrigger: {
        type: Boolean,
        default: void 0
      },
      disabled: {
        type: Boolean,
        default: void 0
      },
      ignoreNonKeyboardFocus: {
        type: Boolean,
        default: void 0
      }
    },
    emits: [
      "update:open"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit = __emit;
      useForwardExpose();
      const providerContext = injectTooltipProviderContext();
      const disableHoverableContent = computed(() => props.disableHoverableContent ?? providerContext.disableHoverableContent.value);
      const disableClosingTrigger = computed(() => props.disableClosingTrigger ?? providerContext.disableClosingTrigger.value);
      const disableTooltip = computed(() => props.disabled ?? providerContext.disabled.value);
      const delayDuration = computed(() => props.delayDuration ?? providerContext.delayDuration.value);
      const ignoreNonKeyboardFocus = computed(() => props.ignoreNonKeyboardFocus ?? providerContext.ignoreNonKeyboardFocus.value);
      const open = useVModel(props, "open", emit, {
        defaultValue: props.defaultOpen,
        passive: props.open === void 0
      });
      watch(open, (isOpen) => {
        if (!providerContext.onClose) return;
        if (isOpen) {
          providerContext.onOpen();
          document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
        } else {
          providerContext.onClose();
        }
      });
      const wasOpenDelayedRef = ref(false);
      const trigger = ref();
      const stateAttribute = computed(() => {
        if (!open.value) return "closed";
        return wasOpenDelayedRef.value ? "delayed-open" : "instant-open";
      });
      const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
        wasOpenDelayedRef.value = true;
        open.value = true;
      }, delayDuration, {
        immediate: false
      });
      function handleOpen() {
        clearTimer();
        wasOpenDelayedRef.value = false;
        open.value = true;
      }
      function handleClose() {
        clearTimer();
        open.value = false;
      }
      function handleDelayedOpen() {
        startTimer();
      }
      provideTooltipRootContext({
        contentId: "",
        open,
        stateAttribute,
        trigger,
        onTriggerChange(el) {
          trigger.value = el;
        },
        onTriggerEnter() {
          if (providerContext.isOpenDelayed.value) handleDelayedOpen();
          else handleOpen();
        },
        onTriggerLeave() {
          if (disableHoverableContent.value) {
            handleClose();
          } else {
            clearTimer();
          }
        },
        onOpen: handleOpen,
        onClose: handleClose,
        disableHoverableContent,
        disableClosingTrigger,
        disabled: disableTooltip,
        ignoreNonKeyboardFocus
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$8), null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {
              open: unref(open)
            })
          ]),
          _: 3
        });
      };
    }
  });
  const _sfc_main$6 = defineComponent({
    __name: "TooltipTrigger",
    props: {
      reference: {},
      asChild: {
        type: Boolean
      },
      as: {
        default: "button"
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectTooltipRootContext();
      const providerContext = injectTooltipProviderContext();
      rootContext.contentId || (rootContext.contentId = useId(void 0, "reka-tooltip-content"));
      const { forwardRef, currentElement: triggerElement } = useForwardExpose();
      const isPointerDown = ref(false);
      const hasPointerMoveOpened = ref(false);
      const tooltipListeners = computed(() => {
        if (rootContext.disabled.value) return {};
        return {
          click: handleClick,
          focus: handleFocus,
          pointermove: handlePointerMove,
          pointerleave: handlePointerLeave,
          pointerdown: handlePointerDown,
          blur: handleBlur
        };
      });
      onMounted(() => {
        rootContext.onTriggerChange(triggerElement.value);
      });
      function handlePointerUp() {
        setTimeout(() => {
          isPointerDown.value = false;
        }, 1);
      }
      function handlePointerDown() {
        isPointerDown.value = true;
        document.addEventListener("pointerup", handlePointerUp, {
          once: true
        });
      }
      function handlePointerMove(event) {
        if (event.pointerType === "touch") return;
        if (!hasPointerMoveOpened.value && !providerContext.isPointerInTransitRef.value) {
          rootContext.onTriggerEnter();
          hasPointerMoveOpened.value = true;
        }
      }
      function handlePointerLeave() {
        rootContext.onTriggerLeave();
        hasPointerMoveOpened.value = false;
      }
      function handleFocus(event) {
        var _a2, _b;
        if (isPointerDown.value) return;
        if (rootContext.ignoreNonKeyboardFocus.value && !((_b = (_a2 = event.target).matches) == null ? void 0 : _b.call(_a2, ":focus-visible"))) return;
        rootContext.onOpen();
      }
      function handleBlur() {
        rootContext.onClose();
      }
      function handleClick() {
        if (!rootContext.disableClosingTrigger.value) rootContext.onClose();
      }
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$9), {
          "as-child": "",
          reference: _ctx.reference
        }, {
          default: withCtx(() => [
            createVNode(unref(Primitive), mergeProps({
              ref: unref(forwardRef),
              "aria-describedby": unref(rootContext).open.value ? unref(rootContext).contentId : void 0,
              "data-state": unref(rootContext).stateAttribute.value,
              as: _ctx.as,
              "as-child": props.asChild,
              "data-grace-area-trigger": ""
            }, toHandlers(tooltipListeners.value)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16, [
              "aria-describedby",
              "data-state",
              "as",
              "as-child"
            ])
          ]),
          _: 3
        }, 8, [
          "reference"
        ]);
      };
    }
  });
  const _sfc_main$5 = defineComponent({
    __name: "TooltipContentImpl",
    props: {
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {
        default: "top"
      },
      sideOffset: {
        default: 0
      },
      align: {
        default: "center"
      },
      alignOffset: {},
      avoidCollisions: {
        type: Boolean,
        default: true
      },
      collisionBoundary: {
        default: () => []
      },
      collisionPadding: {
        default: 0
      },
      arrowPadding: {
        default: 0
      },
      sticky: {
        default: "partial"
      },
      hideWhenDetached: {
        type: Boolean,
        default: false
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectTooltipRootContext();
      const { forwardRef } = useForwardExpose();
      const slot = useSlots();
      const defaultSlot = computed(() => {
        var _a2;
        return (_a2 = slot.default) == null ? void 0 : _a2.call(slot, {});
      });
      const ariaLabel = computed(() => {
        var _a2;
        if (props.ariaLabel) return props.ariaLabel;
        let content = "";
        function recursiveTextSearch(node) {
          if (typeof node.children === "string" && node.type !== Comment) content += node.children;
          else if (Array.isArray(node.children)) node.children.forEach((child) => recursiveTextSearch(child));
        }
        (_a2 = defaultSlot.value) == null ? void 0 : _a2.forEach((node) => recursiveTextSearch(node));
        return content;
      });
      const popperContentProps = computed(() => {
        const { ariaLabel: _, ...restProps } = props;
        return restProps;
      });
      onMounted(() => {
        useEventListener(window, "scroll", (event) => {
          const target = event.target;
          if (target == null ? void 0 : target.contains(rootContext.trigger.value)) rootContext.onClose();
        });
        useEventListener(window, TOOLTIP_OPEN, rootContext.onClose);
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$c), {
          "as-child": "",
          "disable-outside-pointer-events": false,
          onEscapeKeyDown: _cache[0] || (_cache[0] = ($event) => emits("escapeKeyDown", $event)),
          onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
            var _a2;
            if (unref(rootContext).disableClosingTrigger.value && ((_a2 = unref(rootContext).trigger.value) == null ? void 0 : _a2.contains(event.target))) event.preventDefault();
            emits("pointerDownOutside", event);
          }),
          onFocusOutside: _cache[2] || (_cache[2] = withModifiers(() => {
          }, [
            "prevent"
          ])),
          onDismiss: _cache[3] || (_cache[3] = ($event) => unref(rootContext).onClose())
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$a), mergeProps({
              ref: unref(forwardRef),
              "data-state": unref(rootContext).stateAttribute.value
            }, {
              ..._ctx.$attrs,
              ...popperContentProps.value
            }, {
              style: {
                "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
                "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
                "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
                "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
                "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
              }
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default"),
                createVNode(unref(_sfc_main$b), {
                  id: unref(rootContext).contentId,
                  role: "tooltip"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(ariaLabel.value), 1)
                  ]),
                  _: 1
                }, 8, [
                  "id"
                ])
              ]),
              _: 3
            }, 16, [
              "data-state"
            ])
          ]),
          _: 3
        });
      };
    }
  });
  const _sfc_main$4 = defineComponent({
    __name: "TooltipContentHoverable",
    props: {
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {},
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    setup(__props) {
      const props = __props;
      const forwardedProps = useForwardProps(props);
      const { forwardRef, currentElement } = useForwardExpose();
      const { trigger, onClose } = injectTooltipRootContext();
      const providerContext = injectTooltipProviderContext();
      const { isPointerInTransit, onPointerExit } = useGraceArea(trigger, currentElement);
      providerContext.isPointerInTransitRef = isPointerInTransit;
      onPointerExit(() => {
        onClose();
      });
      return (_ctx, _cache) => {
        return openBlock(), createBlock(_sfc_main$5, mergeProps({
          ref: unref(forwardRef)
        }, unref(forwardedProps)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _sfc_main$3 = defineComponent({
    __name: "TooltipContent",
    props: {
      forceMount: {
        type: Boolean
      },
      ariaLabel: {},
      asChild: {
        type: Boolean
      },
      as: {},
      side: {
        default: "top"
      },
      sideOffset: {},
      align: {},
      alignOffset: {},
      avoidCollisions: {
        type: Boolean
      },
      collisionBoundary: {},
      collisionPadding: {},
      arrowPadding: {},
      sticky: {},
      hideWhenDetached: {
        type: Boolean
      },
      positionStrategy: {},
      updatePositionStrategy: {}
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectTooltipRootContext();
      const forwarded = useForwardPropsEmits(props, emits);
      const { forwardRef } = useForwardExpose();
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(Presence), {
          present: _ctx.forceMount || unref(rootContext).open.value
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(unref(rootContext).disableHoverableContent.value ? _sfc_main$5 : _sfc_main$4), mergeProps({
              ref: unref(forwardRef)
            }, unref(forwarded)), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 16))
          ]),
          _: 3
        }, 8, [
          "present"
        ]);
      };
    }
  });
  const _sfc_main$2 = defineComponent({
    __name: "TooltipArrow",
    props: {
      width: {
        default: 10
      },
      height: {
        default: 5
      },
      asChild: {
        type: Boolean
      },
      as: {
        default: "svg"
      }
    },
    setup(__props) {
      const props = __props;
      useForwardExpose();
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$d), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const _sfc_main$1 = defineComponent({
    __name: "TooltipPortal",
    props: {
      to: {},
      disabled: {
        type: Boolean
      },
      defer: {
        type: Boolean
      },
      forceMount: {
        type: Boolean
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$e), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 16);
      };
    }
  });
  const theme = {
    "slots": {
      "content": "flex items-center gap-1 bg-(--ui-bg) text-(--ui-text-highlighted) shadow-sm rounded-(--ui-radius) ring ring-(--ui-border) h-6 px-2 py-1 text-xs select-none data-[state=delayed-open]:animate-[scale-in_100ms_ease-out] data-[state=closed]:animate-[scale-out_100ms_ease-in] pointer-events-auto",
      "arrow": "fill-(--ui-border)",
      "text": "truncate",
      "kbds": "hidden lg:inline-flex items-center shrink-0 gap-0.5 before:content-['\xB7'] before:me-0.5",
      "kbdsSize": "sm"
    }
  };
  const appConfigTooltip = _appConfig;
  const tooltip = tv({
    extend: tv(theme),
    ...((_a = appConfigTooltip.ui) == null ? void 0 : _a.tooltip) || {}
  });
  _sfc_main = defineComponent({
    __name: "Tooltip",
    props: {
      text: {},
      kbds: {},
      content: {},
      arrow: {
        type: [
          Boolean,
          Object
        ]
      },
      portal: {
        type: Boolean,
        default: true
      },
      class: {},
      ui: {},
      defaultOpen: {
        type: Boolean
      },
      open: {
        type: Boolean
      },
      delayDuration: {},
      disableHoverableContent: {
        type: Boolean
      },
      disableClosingTrigger: {
        type: Boolean
      },
      disabled: {
        type: Boolean
      },
      ignoreNonKeyboardFocus: {
        type: Boolean
      }
    },
    emits: [
      "update:open"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const slots = useSlots();
      const rootProps = useForwardPropsEmits(reactivePick(props, "defaultOpen", "open", "delayDuration", "disableHoverableContent", "disableClosingTrigger", "disabled", "ignoreNonKeyboardFocus"), emits);
      const contentProps = toRef(() => defu(props.content, {
        side: "bottom",
        sideOffset: 8,
        collisionPadding: 8
      }));
      const arrowProps = toRef(() => props.arrow);
      const ui = computed(() => tooltip({
        side: contentProps.value.side
      }));
      return (_ctx, _cache) => {
        return openBlock(), createBlock(unref(_sfc_main$7), normalizeProps(guardReactiveProps(unref(rootProps))), {
          default: withCtx(({ open }) => [
            !!slots.default ? (openBlock(), createBlock(unref(_sfc_main$6), mergeProps({
              key: 0
            }, _ctx.$attrs, {
              "as-child": "",
              class: props.class
            }), {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {
                  open
                })
              ]),
              _: 2
            }, 1040, [
              "class"
            ])) : createCommentVNode("", true),
            createVNode(unref(_sfc_main$1), {
              disabled: !_ctx.portal
            }, {
              default: withCtx(() => {
                var _a2;
                return [
                  createVNode(unref(_sfc_main$3), mergeProps(contentProps.value, {
                    class: ui.value.content({
                      class: [
                        !slots.default && props.class,
                        (_a2 = props.ui) == null ? void 0 : _a2.content
                      ]
                    })
                  }), {
                    default: withCtx(() => {
                      var _a3;
                      return [
                        renderSlot(_ctx.$slots, "content", {}, () => {
                          var _a4, _b, _c;
                          return [
                            _ctx.text ? (openBlock(), createElementBlock("span", {
                              key: 0,
                              class: normalizeClass(ui.value.text({
                                class: (_a4 = props.ui) == null ? void 0 : _a4.text
                              }))
                            }, toDisplayString(_ctx.text), 3)) : createCommentVNode("", true),
                            ((_b = _ctx.kbds) == null ? void 0 : _b.length) ? (openBlock(), createElementBlock("span", {
                              key: 1,
                              class: normalizeClass(ui.value.kbds({
                                class: (_c = props.ui) == null ? void 0 : _c.kbds
                              }))
                            }, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.kbds, (kbd, index) => {
                                var _a5;
                                return openBlock(), createBlock(_sfc_main$f, mergeProps({
                                  key: index,
                                  size: ((_a5 = props.ui) == null ? void 0 : _a5.kbdsSize) || ui.value.kbdsSize(),
                                  ref_for: true
                                }, typeof kbd === "string" ? {
                                  value: kbd
                                } : kbd), null, 16, [
                                  "size"
                                ]);
                              }), 128))
                            ], 2)) : createCommentVNode("", true)
                          ];
                        }),
                        !!_ctx.arrow ? (openBlock(), createBlock(unref(_sfc_main$2), mergeProps({
                          key: 0
                        }, arrowProps.value, {
                          class: ui.value.arrow({
                            class: (_a3 = props.ui) == null ? void 0 : _a3.arrow
                          })
                        }), null, 16, [
                          "class"
                        ])) : createCommentVNode("", true)
                      ];
                    }),
                    _: 3
                  }, 16, [
                    "class"
                  ])
                ];
              }),
              _: 3
            }, 8, [
              "disabled"
            ])
          ]),
          _: 3
        }, 16);
      };
    }
  });
});
export {
  _sfc_main as _,
  __tla
};
